import os
import sys
from Crypto.Cipher import AES

# use the  key generated by the encryption script
STRONG_AES_KEY = bytes.fromhex('d5e6373083df2de4c9380ffc2818c81793f64649b09d1894e851abc0c506400d') 

ENCRYPTED_INPUT_FILE = 'captured_secure_gcm_traffic.bin'

DECRYPTED_VIDEO_FILE = 'reconstructed_video_secure.mp4'
DECRYPTED_AUDIO_FILE = 'reconstructed_audio_secure.wav'

# expected sizes from GCM
GCM_NONCE_SIZE = 12
GCM_TAG_SIZE = 16

# type flags
VIDEO_FLAG = b'\x01'
AUDIO_FLAG = b'\x02'

# AES-GCM Decryption and Verification Function
def aes_gcm_decrypt_verify(nonce, ciphertext, tag, key):
    """Decrypts AES GCM data AND verifies the authentication tag."""
    try:
        cipher = AES.new(key, AES.MODE_GCM, nonce=nonce)
        plaintext = cipher.decrypt_and_verify(ciphertext, tag)
        return plaintext
    except ValueError: # catch MAC check failures specifically
        raise ValueError("MAC check failed")
    except Exception as e:
        return None 

# Main Decryption Process
print(f"--- Secure Simulation: Receiver Decryptor (AES-GCM) ---")
print(f"Using STRONG Key (Hex): {STRONG_AES_KEY.hex()}")
print(f"Input File: {ENCRYPTED_INPUT_FILE}")
print(f"Output Video File: {DECRYPTED_VIDEO_FILE if DECRYPTED_VIDEO_FILE else 'None'}")
print(f"Output Audio File: {DECRYPTED_AUDIO_FILE if DECRYPTED_AUDIO_FILE else 'None'}")

if not DECRYPTED_VIDEO_FILE and not DECRYPTED_AUDIO_FILE:
     sys.exit("Error: No output files specified.")

f_in = None
f_out_vid = None
f_out_aud = None
files_opened = []

try:
    # open input file
    f_in = open(ENCRYPTED_INPUT_FILE, 'rb')

    if DECRYPTED_VIDEO_FILE:
        try: f_out_vid = open(DECRYPTED_VIDEO_FILE, 'wb'); files_opened.append(f_out_vid); print(f"Opened output video: {DECRYPTED_VIDEO_FILE}")
        except IOError as e: print(f"Warning: Could not open output video file '{DECRYPTED_VIDEO_FILE}': {e}"); f_out_vid = None
    if DECRYPTED_AUDIO_FILE:
         try: f_out_aud = open(DECRYPTED_AUDIO_FILE, 'wb'); files_opened.append(f_out_aud); print(f"Opened output audio: {DECRYPTED_AUDIO_FILE}")
         except IOError as e: print(f"Warning: Could not open output audio file '{DECRYPTED_AUDIO_FILE}': {e}"); f_out_aud = None
    if not files_opened: sys.exit("Error: Failed to open any output files.")

    block_number = 0
    blocks_failed_verification = 0
    first_failure_logged = False # flag to track if we've printed the error

    while True:
        block_number += 1
        # read total block length, nonce, tag, ciphertext 
        length_bytes = f_in.read(4)
        if not length_bytes: break
        if len(length_bytes) < 4: print("\nWarning: Incomplete length data."); break
        block_len = int.from_bytes(length_bytes, 'big')

        nonce = f_in.read(GCM_NONCE_SIZE)
        if len(nonce) < GCM_NONCE_SIZE: print("\nWarning: Incomplete nonce data."); break

        tag = f_in.read(GCM_TAG_SIZE)
        if len(tag) < GCM_TAG_SIZE: print("\nWarning: Incomplete tag data."); break

        ciphertext_len = block_len - GCM_NONCE_SIZE - GCM_TAG_SIZE
        if ciphertext_len < 0: print(f"\nError: Invalid block length {block_len} in block {block_number}."); break
        ciphertext = f_in.read(ciphertext_len)
        if len(ciphertext) < ciphertext_len: print(f"\nWarning: Incomplete ciphertext data in block {block_number}."); break

        # decrypt and verify using the strong key
        decrypted_data = None # assume failure until proven otherwise
        try:
            decrypted_data = aes_gcm_decrypt_verify(nonce, ciphertext, tag, STRONG_AES_KEY)
        except ValueError as e: # catch the specific MAC check failure
             blocks_failed_verification += 1
             if not first_failure_logged:
                 print(f"\nIntegrity Check FAILED! (First failure at Block {block_number}). Likely incorrect key or corrupted data. Error: {e}. Further failures will be suppressed.")
                 first_failure_logged = True
             # continue to next block without processing this one
             continue
        except Exception as e: # catch other potential decryption errors
             blocks_failed_verification += 1
             if not first_failure_logged:
                 print(f"\nDecryption Error! (First error at Block {block_number}). Error: {e}. Further failures will be suppressed.")
                 first_failure_logged = True
             # continue to next block
             continue


        # successfully decrypted and verified data
        if decrypted_data:
            type_flag = decrypted_data[0:1]
            payload = decrypted_data[1:]

            if type_flag == VIDEO_FLAG and f_out_vid:
                f_out_vid.write(payload)
            elif type_flag == AUDIO_FLAG and f_out_aud:
                f_out_aud.write(payload)

    if first_failure_logged:
        print() 

    print(f"\nDecryption attempt complete.")
    if blocks_failed_verification > 0:
        print(f"WARNING: {blocks_failed_verification} block(s) failed integrity check or decryption and were discarded.")

except FileNotFoundError:
    print(f"\nError: Ensure input file '{ENCRYPTED_INPUT_FILE}' exists.")
except ImportError:
     print("\nError: PyCryptodome library not found (`pip install pycryptodome`).")
except Exception as e:
    print(f"\nAn error occurred during setup or file reading: {e}")
finally:
    # ensure all opened files are closed
    if f_in: f_in.close()
    if f_out_vid: f_out_vid.close()
    if f_out_aud: f_out_aud.close()